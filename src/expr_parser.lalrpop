// This module is midly more messy than a "classic" AST build because I'm
// building the AST using gc-arena allocations. This makes the AST immediately
// usable for interpretation. I'm not sure it's a great decision to conflate the
// two so early, but it's a decision.
use crate::expr::{Expr, GcExpr, Symbol};
use gc_arena::{Gc, MutationContext};
use std::str::FromStr;


grammar<'gc, 'cx>(mc: MutationContext<'gc, 'cx>);

pub Id: Symbol = {
    r"[a-zA-Z_][a-zA-Z0-_'\\-]*" => Symbol::from(<>)
}

pub Int: GcExpr<'gc> = {
    r"[0-9]+" => Gc::allocate(mc, Expr::Int(i64::from_str(<>).unwrap()))
};

Path: String = {
    r"[a-zA-Z0-9\\._\-\+]*(/[a-zA-Z0-9\\._\-\+]+)+/?" => String::from(<>)
}

pub expr: GcExpr<'gc> = { lambda_def };


pub lambda_def: GcExpr<'gc> = {
    <arg:Id> ":" <body:expr_function> => {
         Gc::allocate(mc, Expr::Lambda { arg: Some(arg), body, formals: (vec![], false) }) },
    // "{" <formals:formal+> "}" ":" <body:expr_function> => {
    //      Gc::allocate(mc, Expr::Lambda { arg: None, formals, body }) },
    // "{" <formals:formal+> "}" "@" <arg:Id> ":" <body:expr_function> => {
    //      Gc::allocate(mc, Expr::Lambda { arg: Some(arg), formals, body }) },
    <arg:Id> "@" "{" <formals:formals> "}" ":" <body:expr_function> => {
        // TODO handle ... or move the @ handling down
        Gc::allocate(mc, Expr::Lambda { arg: Some(arg), formals: (formals, false), body }) },
    "{" <formals_or_binds:formals_or_binds> => { formals_or_binds },
    expr_function,
}

// "{" starting both functions and attr sets, each with different precedences,
// is a real pain for shift-reduce conflicts. We need to prefix-match as
// described here: http://smallcultfollowing.com/babysteps/blog/2016/03/02/nice-errors-in-lalrpop/

// Things can get quite wild:
// (({ a, b ? {}: 1 }: b){ a = 10; }){}
pub formals_or_binds: GcExpr<'gc> = {
    "}"  ":" <body:expr_function> => {
        Gc::allocate(mc, Expr::Lambda { arg: None, formals: (vec![], false), body })
    },
    "..." "}"  ":" <body:expr_function> => {
        Gc::allocate(mc, Expr::Lambda { arg: None, formals: (vec![], true), body })
    },
    <formals:formals> "}"  ":" <body:expr_function> => {
        Gc::allocate(mc, Expr::Lambda { arg: None, formals: (formals, false), body })
    },
    <formals:formals> "," "..." "}"  ":" <body:expr_function> => {
        Gc::allocate(mc, Expr::Lambda { arg: None, formals: (formals, true), body })
    },
    "}" => {
        Gc::allocate(mc, Expr::Attrs { recursive: false, attrs: Vec::new() })
    },
    <attrs:binds> "}" => {
        Gc::allocate(mc, Expr::Attrs { recursive: false, attrs })
    },
}

pub expr_function: GcExpr<'gc> = {
    "assert" <expr:expr> ";" <body:expr_function> => {
         Gc::allocate(mc, Expr::Assert { expr, body }) },
    "with" <expr:expr> ";" <body:expr_function> => {
         Gc::allocate(mc, Expr::With { expr, body }) },
    "let" <bindings:binds> "in" <body:expr_function> => {
         Gc::allocate(mc, Expr::Let { bindings, body }) },
    expr_if,
};

pub expr_if: GcExpr<'gc> = {
    "if" <if_expr:expr> "then" <then_expr:expr> "else" <else_expr:expr> =>
        { Gc::allocate(mc, Expr::IfThenElse { if_expr, then_expr, else_expr }) },
    expr_op_p13,
}

// -----------------------------------------------------------------------
// operator precedence
// https://nixos.org/nix/manual/#sec-language-operators
pub expr_op_p1: GcExpr<'gc> = {
    <left:expr_op_p1> "." <right:expr_simple> =>
        { Gc::allocate(mc, Expr::Select { expr: left, attr_path: right }) },
    expr_simple
}
pub expr_op_p2: GcExpr<'gc> = {
    <left:expr_op_p2> <right:expr_op_p1> =>
        { Gc::allocate(mc, Expr::App { arity: 1, f: left, args: vec![right] }) },
    expr_op_p1
}
pub expr_op_p3: GcExpr<'gc> = {
    "-" <expr:expr_op_p2> =>
        { Gc::allocate(mc, Expr::UnaryMinus { expr }) },
    expr_op_p2
}
pub expr_op_p4: GcExpr<'gc> = {
    <expr:expr_op_p4> "?" <attr_path:attrpath> =>
        { Gc::allocate(mc, Expr::HasAttr { expr, attr_path }) },
    expr_op_p3
}
pub expr_op_p5: GcExpr<'gc> = {
    <left:expr_op_p5> "++" <right:expr_op_p4> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "++",  left, right }) },
    expr_op_p4
}
pub expr_op_p6: GcExpr<'gc> = {
    <left:expr_op_p6> "*" <right:expr_op_p5> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "*",  left, right }) },
    <left:expr_op_p6> "/" <right:expr_op_p5> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "/",  left, right }) },
    expr_op_p5
}
pub expr_op_p7: GcExpr<'gc> = {
    // <left:expr_op> "+" <right:expr_op> =>
    //     { Gc::allocate(mc, Expr::BinaryOp { name: "string+",  left, right }) }, TODO string concat has higher precedence
    <left:expr_op_p7> "+" <right:expr_op_p6> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "+",  left, right }) },
    <left:expr_op_p7> "-" <right:expr_op_p6> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "-",  left, right }) },
    expr_op_p6
}
pub expr_op_p8: GcExpr<'gc> = {
    "!" <expr:expr_op_p7> =>
        { Gc::allocate(mc, Expr::UnaryNot { expr }) }, // TODO mono-op
    expr_op_p7
}
pub expr_op_p9: GcExpr<'gc> = {
    <left:expr_op_p9> "//" <right:expr_op_p8> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "//",  left, right }) },
    expr_op_p8
}
pub expr_op_p10: GcExpr<'gc> = {
    <left:expr_op_p10> "<" <right:expr_op_p9> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "<",  left, right }) },
    <left:expr_op_p10> "<=" <right:expr_op_p9> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "<=",  left, right }) },
    <left:expr_op_p10> ">" <right:expr_op_p9> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: ">",  left, right }) },
    <left:expr_op_p10> ">=" <right:expr_op_p9> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: ">=",  left, right }) },
    expr_op_p9,
}
pub expr_op_p11: GcExpr<'gc> = {
    <left:expr_op_p11> "==" <right:expr_op_p10> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "==",  left, right }) },
    <left:expr_op_p11> "!=" <right:expr_op_p10> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "!=",  left, right }) },
    expr_op_p10,
}
pub expr_op_p12: GcExpr<'gc> = {
    <left:expr_op_p12> "&&" <right:expr_op_p11> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "&&",  left, right }) },
    expr_op_p11,
}
pub expr_op_p13: GcExpr<'gc> = {
    <left:expr_op_p13> "||" <right:expr_op_p12> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "||",  left, right }) },
    expr_op_p12,
}
pub expr_op_p14: GcExpr<'gc> = {
    <left:expr_op_p14> "->" <right:expr_op_p13> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "->",  left, right }) },
    expr_op_p13,
}
// -----------------------------------------------------------------------


// expr_select: GcExpr<'gc> = {
//     <expr:expr_simple> "." <attr_path:attrpath> => {
//         Gc::allocate(mc, Expr::Select { expr, attr_path })
//     },
//     // { a = "a"; }.b or "b" - I had no idea ..
//     <expr:expr_simple> "." <attr_path_left:attrpath> "or" <attr_path_right:attrpath> => {
//         Gc::allocate(mc, Expr::SelectOr { expr, attr_path_left, attr_path_right })
//     },
//     // | /* Backwards compatibility: because Nixpkgs has a rarely used
//     //    function named ‘or’, allow stuff like ‘map or [...]’. */
//     // expr_simple OR_KW
//     // { $$ = new ExprApp(CUR_POS, $1, new ExprVar(CUR_POS, data->symbols.create("or"))); }
//     expr_simple
// }

// TODO what is HPATH and SPATH?
// TODO do we want to keep URIs?
// TODO floats
expr_simple: GcExpr<'gc> = {
    <id:Id> => {
        Gc::allocate(mc, Expr::Var(id))
    },
    r"[0-9]+" => {
        Gc::allocate(mc, Expr::Int(i64::from_str(<>).unwrap()))
    },
    <parts:string_parts> => {
         Gc::allocate(mc, Expr::String(parts))
    },
    // "''" <parts:ind_string_parts> "''" => {
    //     Gc::allocate(mc, Expr::String(parts))
    // }, // TODO strip indendtation
    <path:Path> => {
        Gc::allocate(mc, Expr::Path(path))
    },
    "(" <expr:expr> ")" => {
        expr
    },
    // TODO - let body doesn't seem to happen at all in <nixpkgs>?
    // Let expressions `let {..., body = ...}" are just desugared
    // into `(rec {..., body = ...}).body".
    // "let" "{" <expr:binds> "}" =>
    //     { // TODO make binds recursive here? Seems to me they should always return recursive?
    //         Gc::allocate(mc, Expr::Select(expr, attr_path: Symbol("body")) }
    "rec" "{" <attrs:binds> "}" => {
        Gc::allocate(mc, Expr::Attrs { recursive: true, attrs })
    }, // replace attrs?

    // "{" <attrs:binds> "}" => {
    //     Gc::allocate(mc, Expr::Attrs { recursive: false, attrs })
    // },
    "[" <list:expr_list> "]" => {
        Gc::allocate(mc, Expr::List(list))
    },
}

// TODO - string interpolation needs to mop up symbols until it hits "${"
//
string_parts: String = {
    r#""[^"]*""# => String::from(<>)
}
//   : STR
//   | string_parts_interpolated { $$ = new ExprConcatStrings(CUR_POS, true, $1); }
//   | { $$ = new ExprString(data->symbols.create("")); }
//   ;

// string_parts_interpolated
//   : string_parts_interpolated STR { $$ = $1; $1->push_back($2); }
//   | string_parts_interpolated "${" expr "}" { $$ = $1; $1->push_back($3); }
//   | "${" expr "}" { $$ = new vector<Expr *>; $$->push_back($2); }
//   | STR "${" expr "}" {
//       $$ = new vector<Expr *>;
//       $$->push_back($1);
//       $$->push_back($3);
//     }
//   ;

// ind_string_parts
//   : ind_string_parts IND_STR { $$ = $1; $1->push_back($2); }
//   | ind_string_parts "${" expr "}" { $$ = $1; $1->push_back($3); }
//   | { $$ = new vector<Expr *>; }
//   ;

binds: Vec<(Vec<GcExpr<'gc>>, GcExpr<'gc>)> = {
    <bind:bind> => {
        vec![bind]
    },
    <mut binds:binds> <bind:bind> => {
        binds.push(bind);
        binds
    },
    // <mut binds:binds> "inherit" <attrs:attrs> ";" => {
    //     // todo, this is basically "x = x;" but expr in parent env.
    //     binds.insert("inherit attrs".to_string(), Gc::allocate(mc, Expr::InheritedVar("inherit attr".to_string())));
    // },
    //     binds
    // <mut binds:binds> "inherit" "(" <expr:expr> ")" <attr_path:attrs> ";" => {
    //     // Gc::allocate(mc, Expr::Select { expr, attr_path });
    //     binds // TODO select from subexpression created above
    // },
    // => HashMap::new(),
}

bind: (Vec<GcExpr<'gc>>, GcExpr<'gc>) = {
    // TODO - inherit handling
    <attr_path:attrpath> "=" <expr:expr> ";" => {
        (attr_path, expr)
    }
}

attrs: Vec<GcExpr<'gc>> = {
    <mut list:attrs> <attr:attr> => {
        list.push(attr);
        list
    },
   <mut list:attrs> <attr:string_attr> => {
       // TODO check string attr is not "dynamic", i.e. doens't
       // have an expression like "${}" in the string.
       list.push(attr);
       list
   },
   => Vec::new(),
}

attrpath: Vec<GcExpr<'gc>> = {
    <mut attr_path:attrpath> "." <attr:attr> => {
        attr_path.push(attr);
        attr_path
    },
    <mut attr_path:attrpath> "." <string_attr:string_attr> => {
        attr_path.push(string_attr);
        attr_path
    },
    <attr:attr> => { vec![attr] },
    string_attr => { vec![<>] },
}

attr: GcExpr<'gc> = {
    Id => Gc::allocate(mc, Expr::Var(<>)),
}
//   | OR_KW { $$ = "or"; } TODO I really don't understand where the or keyword is happening...

string_attr: GcExpr<'gc> = {
    <parts:string_parts> => {
        // I'm slightly confused about what can be used as a string_attr, (TODO)
        Gc::allocate(mc, Expr::Var(parts))
    },
    // TODO ${} access is a bit confusing, apparently the following is valid and used a lot:
    // let a.b.c = 1; in a.${"b"}
    // e.g. from lib/attrsets.nix:
    // attrVals = nameList: set: map (x: set.${x}) nameList;
    "${" <expr:expr> "}" => { expr },
}

expr_list: Vec<GcExpr<'gc>> = {
    <mut list:expr_list> <expr:expr_simple> =>
        { list.push(expr); list },
    => Vec::new(),
}

formals: Vec<GcExpr<'gc>> = {
    <formal:formal> => {
        vec![formal]
    },
    <mut formals:formals> "," <formal:formal> => {
        formals.push(formal); formals
    },
}

formal: GcExpr<'gc> = {
    Id => {
        Gc::allocate(mc, Expr::Formal(<>, None))
    },
    <id:Id> "?" <expr:expr> => {
        Gc::allocate(mc, Expr::Formal(id, Some(expr)))
    },
}
