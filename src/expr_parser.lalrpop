// This module is midly more messy than a "classic" AST build because I'm
// building the AST using gc-arena allocations. This makes the AST immediately
// usable for interpretation. I'm not sure it's a great decision to conflate the
// two so early, but it's a decision.
use crate::expr::{Expr, GcExpr, Symbol};
use gc_arena::{Gc, MutationContext};
use std::str::FromStr;
use crate::lexer;

grammar<'gc, 'cx>(mc: MutationContext<'gc, 'cx>);


pub expr: GcExpr<'gc> = { lambda_def };


pub lambda_def: GcExpr<'gc> = {
    <arg:ID> ":" <body:expr_function> => {
         Gc::allocate(mc, Expr::Lambda { arg: Some(arg), body, formals: (vec![], false) }) },
    // "{" <formals:formal+> "}" ":" <body:expr_function> => {
    //      Gc::allocate(mc, Expr::Lambda { arg: None, formals, body }) },
    // "{" <formals:formal+> "}" "@" <arg:ID> ":" <body:expr_function> => {
    //      Gc::allocate(mc, Expr::Lambda { arg: Some(arg), formals, body }) },
    <arg:ID> "@" "{" <formals:formals> "}" ":" <body:expr_function> => {
        // TODO handle ... or move the @ handling down
        Gc::allocate(mc, Expr::Lambda { arg: Some(arg), formals: (formals, false), body }) },
    "{" <formals_or_binds:formals_or_binds> => { formals_or_binds },
    expr_function,
}

// "{" starting both functions and attr sets, each with different precedences,
// is a real pain for shift-reduce conflicts. We need to prefix-match as
// described here: http://smallcultfollowing.com/babysteps/blog/2016/03/02/nice-errors-in-lalrpop/

// Things can get quite wild:
// (({ a, b ? {}: 1 }: b){ a = 10; }){}
pub formals_or_binds: GcExpr<'gc> = {
    "}"  ":" <body:expr_function> => {
        Gc::allocate(mc, Expr::Lambda { arg: None, formals: (vec![], false), body })
    },
    "..." "}"  ":" <body:expr_function> => {
        Gc::allocate(mc, Expr::Lambda { arg: None, formals: (vec![], true), body })
    },
    <formals:formals> "}"  ":" <body:expr_function> => {
        Gc::allocate(mc, Expr::Lambda { arg: None, formals: (formals, false), body })
    },
    <formals:formals> "," "..." "}"  ":" <body:expr_function> => {
        Gc::allocate(mc, Expr::Lambda { arg: None, formals: (formals, true), body })
    },
    "}" => {
        Gc::allocate(mc, Expr::Attrs { recursive: false, attrs: Vec::new() })
    },
    <attrs:binds> "}" => {
        Gc::allocate(mc, Expr::Attrs { recursive: false, attrs })
    },
}

pub expr_function: GcExpr<'gc> = {
    "assert" <expr:expr> ";" <body:expr_function> => {
         Gc::allocate(mc, Expr::Assert { expr, body }) },
    "with" <expr:expr> ";" <body:expr_function> => {
         Gc::allocate(mc, Expr::With { expr, body }) },
    "let" <bindings:binds> "in" <body:expr_function> => {
         Gc::allocate(mc, Expr::Let { bindings, body }) },
    expr_if,
};

pub expr_if: GcExpr<'gc> = {
    "if" <if_expr:expr> "then" <then_expr:expr> "else" <else_expr:expr> =>
        { Gc::allocate(mc, Expr::IfThenElse { if_expr, then_expr, else_expr }) },
    expr_op_p13,
}

// -----------------------------------------------------------------------
// operator precedence
// https://nixos.org/nix/manual/#sec-language-operators
pub expr_op_p1: GcExpr<'gc> = {
    <left:expr_op_p1> "." <right:expr_simple> =>
        { Gc::allocate(mc, Expr::Select { expr: left, attr_path: right }) },
    expr_simple
}
pub expr_op_p2: GcExpr<'gc> = {
    <left:expr_op_p2> <right:expr_op_p1> =>
        { Gc::allocate(mc, Expr::App { arity: 1, f: left, args: vec![right] }) },
    expr_op_p1
}
pub expr_op_p3: GcExpr<'gc> = {
    "-" <expr:expr_op_p2> =>
        { Gc::allocate(mc, Expr::UnaryMinus { expr }) },
    expr_op_p2
}
pub expr_op_p4: GcExpr<'gc> = {
    <expr:expr_op_p4> "?" <attr_path:attrpath> =>
        { Gc::allocate(mc, Expr::HasAttr { expr, attr_path }) },
    expr_op_p3
}
pub expr_op_p5: GcExpr<'gc> = {
    <left:expr_op_p5> "++" <right:expr_op_p4> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "++",  left, right }) },
    expr_op_p4
}
pub expr_op_p6: GcExpr<'gc> = {
    <left:expr_op_p6> "*" <right:expr_op_p5> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "*",  left, right }) },
    <left:expr_op_p6> "/" <right:expr_op_p5> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "/",  left, right }) },
    expr_op_p5
}
pub expr_op_p7: GcExpr<'gc> = {
    // <left:expr_op> "+" <right:expr_op> =>
    //     { Gc::allocate(mc, Expr::BinaryOp { name: "string+",  left, right }) }, TODO string concat has higher precedence
    <left:expr_op_p7> "+" <right:expr_op_p6> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "+",  left, right }) },
    <left:expr_op_p7> "-" <right:expr_op_p6> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "-",  left, right }) },
    expr_op_p6
}
pub expr_op_p8: GcExpr<'gc> = {
    "!" <expr:expr_op_p7> =>
        { Gc::allocate(mc, Expr::UnaryNot { expr }) }, // TODO mono-op
    expr_op_p7
}
pub expr_op_p9: GcExpr<'gc> = {
    <left:expr_op_p9> "//" <right:expr_op_p8> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "//",  left, right }) },
    expr_op_p8
}
pub expr_op_p10: GcExpr<'gc> = {
    <left:expr_op_p10> "<" <right:expr_op_p9> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "<",  left, right }) },
    <left:expr_op_p10> "<=" <right:expr_op_p9> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "<=",  left, right }) },
    <left:expr_op_p10> ">" <right:expr_op_p9> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: ">",  left, right }) },
    <left:expr_op_p10> ">=" <right:expr_op_p9> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: ">=",  left, right }) },
    expr_op_p9,
}
pub expr_op_p11: GcExpr<'gc> = {
    <left:expr_op_p11> "==" <right:expr_op_p10> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "==",  left, right }) },
    <left:expr_op_p11> "!=" <right:expr_op_p10> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "!=",  left, right }) },
    expr_op_p10,
}
pub expr_op_p12: GcExpr<'gc> = {
    <left:expr_op_p12> "&&" <right:expr_op_p11> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "&&",  left, right }) },
    expr_op_p11,
}
pub expr_op_p13: GcExpr<'gc> = {
    <left:expr_op_p13> "||" <right:expr_op_p12> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "||",  left, right }) },
    expr_op_p12,
}
pub expr_op_p14: GcExpr<'gc> = {
    <left:expr_op_p14> "->" <right:expr_op_p13> =>
        { Gc::allocate(mc, Expr::BinaryOp { name: "->",  left, right }) },
    expr_op_p13,
}
// -----------------------------------------------------------------------

// TODO what is HPATH and SPATH?
// TODO do we want to keep URIs?
// TODO floats
expr_simple: GcExpr<'gc> = {
    <id:ID> => {
        Gc::allocate(mc, Expr::Var(id))
    },
    <int:INT> => { int },
    <parts:string_parts> => {
         Gc::allocate(mc, Expr::String(parts))
    },
    // "''" <parts:ind_string_parts> "''" => {
    //     Gc::allocate(mc, Expr::String(parts))
    // }, // TODO strip indendtation
    <path:PATH> => {
        Gc::allocate(mc, Expr::Path(path))
    },
    "(" <expr:expr> ")" => {
        expr
    },
    // TODO - let body doesn't seem to happen at all in <nixpkgs>?
    // Let expressions `let {..., body = ...}" are just desugared
    // into `(rec {..., body = ...}).body".
    // "let" "{" <expr:binds> "}" =>
    //     { // TODO make binds recursive here? Seems to me they should always return recursive?
    //         Gc::allocate(mc, Expr::Select(expr, attr_path: Symbol("body")) }
    "rec" "{" <attrs:binds> "}" => {
        Gc::allocate(mc, Expr::Attrs { recursive: true, attrs })
    }, // replace attrs?

    // "{" <attrs:binds> "}" => {
    //     Gc::allocate(mc, Expr::Attrs { recursive: false, attrs })
    // },
    "[" <list:expr_list> "]" => {
        Gc::allocate(mc, Expr::List(list))
    },
}

// TODO - string interpolation needs to mop up symbols until it hits "${"
//
// contents: &str = r#"([^\$"\\]|\$[^\{"\\])*"#;

string_parts: String = {
    // "\"" <s:contents> "\"" => s.to_string(),
    // "\"" <s:contents> "${" => s.to_string(),
    // <s:INTERP_STRING> <expr:expr> CLOSE_INTERP_STRING => format!("I,{},{:?},I", s, expr), //expr CLOSE_INTERP_STRING => s.to_string(),
    // <s:NORMAL_STRING> => s.to_string(),
}
//   : STR
//   | string_parts_interpolated { $$ = new ExprConcatStrings(CUR_POS, true, $1); }
//   | { $$ = new ExprString(data->symbols.create("")); }
//   ;

// string_parts_interpolated
//   : string_parts_interpolated STR { $$ = $1; $1->push_back($2); }
//   | string_parts_interpolated "${" expr "}" { $$ = $1; $1->push_back($3); }
//   | "${" expr "}" { $$ = new vector<Expr *>; $$->push_back($2); }
//   | STR "${" expr "}" {
//       $$ = new vector<Expr *>;
//       $$->push_back($1);
//       $$->push_back($3);
//     }
//   ;

// ind_string_parts
//   : ind_string_parts IND_STR { $$ = $1; $1->push_back($2); }
//   | ind_string_parts "${" expr "}" { $$ = $1; $1->push_back($3); }
//   | { $$ = new vector<Expr *>; }
//   ;

binds: Vec<(Vec<GcExpr<'gc>>, GcExpr<'gc>)> = {
    <bind:bind> => {
        vec![bind]
    },
    <mut binds:binds> <bind:bind> => {
        binds.push(bind);
        binds
    },
    // <mut binds:binds> "inherit" <attrs:attrs> ";" => {
    //     // todo, this is basically "x = x;" but expr in parent env.
    //     binds.insert("inherit attrs".to_string(), Gc::allocate(mc, Expr::InheritedVar("inherit attr".to_string())));
    // },
    //     binds
    // <mut binds:binds> "inherit" "(" <expr:expr> ")" <attr_path:attrs> ";" => {
    //     // Gc::allocate(mc, Expr::Select { expr, attr_path });
    //     binds // TODO select from subexpression created above
    // },
    // => HashMap::new(),
}

bind: (Vec<GcExpr<'gc>>, GcExpr<'gc>) = {
    // TODO - inherit handling
    <attr_path:attrpath> "=" <expr:expr> ";" => {
        (attr_path, expr)
    }
}

attrs: Vec<GcExpr<'gc>> = {
    <mut list:attrs> <attr:attr> => {
        list.push(attr);
        list
    },
   <mut list:attrs> <attr:string_attr> => {
       // TODO check string attr is not "dynamic", i.e. doens't
       // have an expression like "${}" in the string.
       list.push(attr);
       list
   },
   => Vec::new(),
}

attrpath: Vec<GcExpr<'gc>> = {
    <mut attr_path:attrpath> "." <attr:attr> => {
        attr_path.push(attr);
        attr_path
    },
    <mut attr_path:attrpath> "." <string_attr:string_attr> => {
        attr_path.push(string_attr);
        attr_path
    },
    <attr:attr> => { vec![attr] },
    string_attr => { vec![<>] },
}

attr: GcExpr<'gc> = {
    ID => Gc::allocate(mc, Expr::Var(<>)),
}
//   | OR_KW { $$ = "or"; } TODO I really don't understand where the or keyword is happening...

string_attr: GcExpr<'gc> = {
    <parts:string_parts> => {
        // I'm slightly confused about what can be used as a string_attr, (TODO)
        Gc::allocate(mc, Expr::Var(parts))
    },
    // TODO ${} access is a bit confusing, apparently the following is valid and used a lot:
    // let a.b.c = 1; in a.${"b"}
    // e.g. from lib/attrsets.nix:
    // attrVals = nameList: set: map (x: set.${x}) nameList;
    "${" <expr:expr> "}" => { expr },
}

expr_list: Vec<GcExpr<'gc>> = {
    <mut list:expr_list> <expr:expr_simple> =>
        { list.push(expr); list },
    => Vec::new(),
}

formals: Vec<GcExpr<'gc>> = {
    <formal:formal> => {
        vec![formal]
    },
    <mut formals:formals> "," <formal:formal> => {
        formals.push(formal); formals
    },
}

formal: GcExpr<'gc> = {
    ID => {
        Gc::allocate(mc, Expr::Formal(<>, None))
    },
    <id:ID> "?" <expr:expr> => {
        Gc::allocate(mc, Expr::Formal(id, Some(expr)))
    },
}

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Tok {
        ID => lexer::Tok::ID,
        ","  => lexer::Tok::COMMA,
        INT => lexer::Tok::INT,
        FLOAT =>lexer::Tok::FLOAT,
        STRING_START => lexer::Tok::STRING_START,
        "${" => lexer::Tok::DOLLAR_CURLY,

        "if" => lexer::Tok::IF,
        "then" => lexer::Tok::THEN,
        "else" => lexer::Tok::ELSE,
        "assert" => lexer::Tok::ASSERT,
        "with" => lexer::Tok::WITH,
        "let" => lexer::Tok::LET,
        "in" => lexer::Tok::IN,
        "rec" => lexer::Tok::REC,
        "inherit" => lexer::Tok::INHERIT,
        OR_KW => lexer::Tok::OR_KW,
        "..." => lexer::Tok::ELLIPSIS,

        "," => lexer::Tok::COMMA,
        "." => lexer::Tok::DOT,
        ":" => lexer::Tok::COLON,
        ";" => lexer::Tok::SEMICOLON,
        "?" => lexer::Tok::QUESTIONMARK,
        "//" => lexer::Tok::DOUBLE_FORWARD_SLASH,

        "@" => lexer::Tok::AT,

        "{" => lexer::Tok::OPEN_CURLY,
        "}" => lexer::Tok::CLOSE_CURLY,

        "=" => lexer::Tok::ASSIGN,

        "==" => lexer::Tok::EQ,
        "!=" => lexer::Tok::NEQ,
        "<=" => lexer::Tok::LEQ,
        ">=" => lexer::Tok::GEQ,
        "<" => lexer::Tok::LT,
        ">" => lexer::Tok::GT,
        "&&" => lexer::Tok::AND,
        "||" => lexer::Tok::OR,
        "->" => lexer::Tok::IMPL,
        "//" => lexer::Tok::UPDATE,
        "++" => lexer::Tok::CONCAT,
        "-" => lexer::Tok::MINUS,
        "+" => lexer::Tok::PLUS,
        "/" => lexer::Tok::DIVIDE,
        "*" => lexer::Tok::MULTIPLY,
        "!" => lexer::Tok::NEGATE,

        "(" => lexer::Tok::OPEN_PAREN,
        ")" => lexer::Tok::CLOSE_PAREN,

        "[" => lexer::Tok::OPEN_SQUARE,
        "]" => lexer::Tok::CLOSE_SQUARE,

        PATH => lexer::Tok::PATH,
    }
}